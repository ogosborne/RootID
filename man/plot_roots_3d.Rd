% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot_roots_3d.R
\name{plot_roots_3d}
\alias{plot_roots_3d}
\title{Plot a 3d root map}
\usage{
plot_roots_3d(
  matches,
  ind.list,
  root.pos,
  taxa,
  tax.type,
  cols = NULL,
  draw.legend = NULL,
  abundance.scale.type = "colmax",
  draw.particles = TRUE,
  max.n.particles = 500,
  particle.radius = 0.02,
  particle.alpha = 1,
  particle.threshold = 0,
  alpha.scale.cubes = FALSE,
  max.alpha.scale.cubes = 0.5,
  min.alpha.scale.cubes = 0.05,
  alpha.scale.cube.col = "grey80",
  draw.root.cubes = "n",
  cube.threshold = 0,
  cube.which.vec = NA,
  cube.type = "c",
  cube.alpha = 0.1,
  cube.col = "cornflowerblue",
  draw.root.bbox = TRUE,
  draw.root.grid = FALSE,
  which.root.grid = c("x-", "y+", "z-"),
  root.scale = c(1, 1, 0.2),
  draw.trees = TRUE,
  tree.dat = NULL,
  tree.trunk.col = "saddlebrown",
  tree.trunk.rad = 0.1,
  tree.alpha = 0.5,
  tree.trunk.sides = 100,
  tree.crown.subdivide = 5,
  draw.axes = TRUE,
  root.x.names = NULL,
  root.y.names = NULL,
  root.z.names = NULL,
  which.axes = c(TRUE, TRUE, TRUE),
  which.axis.sides = c("-", "+", "++")
)
}
\arguments{
\item{matches}{the output of \code{match.diag}.}

\item{ind.list}{a named list with a vector for each species containing the names of all individuals of that species.}

\item{root.pos}{a 3D array containing the names of each root sample. See details.}

\item{taxa}{a character vector containing one or more names of species or individuals in \code{matches}}

\item{tax.type}{either 'sp', 'ind', 'sp.ind', or 'vec' (see details).}

\item{cols}{a named character vector containing colors for each species and/or individual to be plotted.}

\item{draw.legend}{logical, whether to draw a legend.}

\item{abundance.scale.type}{either 'colmax' or 'max' (see details)}

\item{draw.particles}{logical, whether to draw particles to indicate root abundance.}

\item{max.n.particles}{integer, the maximum number of root particles to draw per root sample}

\item{particle.radius}{the radius of root particles}

\item{particle.alpha}{float between 0 and 1 determining the opacity of root particles (0 = transparent, 1 = opaque).}

\item{particle.threshold}{minimum abundance above which to draw root particles}

\item{alpha.scale.cubes}{logical, whether to draw scaled transparent cubes to indicate root abundance.}

\item{max.alpha.scale.cubes}{float between 0 and 1, determining the maximum alpha (transparency) of root cubes.}

\item{min.alpha.scale.cubes}{the minimum alpha of root cubes.}

\item{alpha.scale.cube.col}{scaled root cube colour}

\item{draw.root.cubes}{determines whether uniform (unscaled) cubes should be drawn around root samples. Either  'a' (all samples), 'p' (samples where roots are present), 's' (samples specified in \code{cube.which.vec}) or 'n' (none).}

\item{cube.threshold}{the minimum abundance above which to draw uniform cubes if \code{draw.root.cubes = 'p'}}

\item{cube.which.vec}{vector of root sample names to draw uniform cubes round if \code{draw.root.cubes = 's'}.}

\item{cube.type}{determines what type of uniform cubes should be drawn. Either 'l' (lines, i.e. a wire frame) or 'c' (cube, a semi-transparent cube).}

\item{cube.alpha}{float between 0 and 1 determining the opacity of uniform root cubes}

\item{cube.col}{uniform root cube colour}

\item{draw.root.bbox}{logical, whether to draw a bounding box around the root samples}

\item{draw.root.grid}{logical, whether to draw grids on the edge of the root area for x, y and depth axes}

\item{which.root.grid}{character vector determining which sides the grids should be on (see \code{?rgl::grid3d} for details)}

\item{root.scale}{a numeric vector of length = 3, determining how the root axes should be scaled relative to each other, e.g. should the depth axis be flattened.}

\item{draw.trees}{logical, whether 3D scale models of the trees should be drawn.}

\item{tree.dat}{a data frame with (scaled) tree dimension info (see details).}

\item{tree.trunk.col}{colour of the tree trunks.}

\item{tree.trunk.rad}{tree trunk radius (currently the same for all trees in the plot).}

\item{tree.alpha}{transparency of the trees}

\item{tree.trunk.sides}{the number of sides of the tree trunk polygon (higher = smoother but more computationally intensive).}

\item{tree.crown.subdivide}{the number of subdivisions of the tree crown (higher = smoother but more computationally intensive).}

\item{draw.axes}{logical, whether to draw axis labels}

\item{root.x.names, root.y.names, root.z.names}{names for the x, y and z (depth) axes.}

\item{which.axes}{logical vector of length = 3, which axes (x, y and z) to plot axis labels for.}

\item{which.axis.sides}{vector of length = 3 of '+', '-', '++' or '--', determining which side of the axes (x, y and z), axis labels should be plotted on (see 'edge' option in \code{?rgl::mtext3d} for details)}
}
\value{
returns NULL and plots an \code{rgl} object
}
\description{
This function uses the output of \code{match.diag} and information on the position and dimensions of root samples and trees to show the root sampling layout as a three-dimensional grid. Each grid square represents one root sample, and visually displays the abundance of the focal tree or species (either in the form of colour intensity or density of randomly distributed particles within each root sample). Optional three-dimensional models of the trees show their position, height, crown base height, and crown diameter.
}
\details{
The root.pos option shows the position of the root samples relative to each other. It is a 3-dimensional array with dimensions (x, y, z), where x and y are the number of samples along the x and y horizontal axes (corresponding to those in tree.dat) and z is the number of samples along the depth axis (with deeper samples coming first). For example, for samples arranged in a 2 x 2 horizontal grid at 2 depths named "x1_y1_d1", "x2_y1_d1" ... etc, the correct root.pos input would be:

\code{array(c("x1_y2_d2", "x1_y1_d2", "x2_y2_d2", "x2_y1_d2", "x1_y2_d1", "x1_y1_d1", "x2_y2_d1", "x2_y1_d1"), dim = c(2,2,2))}.

The function currently only works in cases where root samples are evenly spread in each direction.

The taxa and tax.type options control which species or individuals are plotted. For \code{tax.type = 'sp'}, one or more species' roots are plotted and \code{taxa} should contain the names of these species. For \code{tax.type = 'ind'}, one or more individuals' roots are plotted and \code{taxa} should contain the names of these individuals. For \code{tax.type = 'sp.ind'}, all individuals of one or more species are plotted and \code{taxa} should contain the names of these species. For \code{tax.type = 'vec'} a mixture of individuals and species can be plotted (listed in \code{taxa}).

For \code{tax.type = 'sp'}, root presence and density are determined from species-diagnostic markers. For \code{tax.type = 'sp.ind'} and \code{tax.type = 'ind'}, root presence and density are determined from individual-diagnostic haplotypes. For \code{tax.type = 'vec'}, root presence and density are determined by individual-diagnostic haplotypes for individuals and species-diagnostic markers for species.

How the root abundance is scaled can be controlled with \code{abundance.scale.type}. For \code{abundance.scale.type = colmax}, abundance (i.e. number of diagnostic marker or haplotype reads detected) is scaled by the maximum detected in any root sample for each species or individual separately. For \code{abundance.scale.type = max}, abundance is scaled by the maximum detected in any root sample across all species or individuals in the plot.

To draw trees, a data frame - \code{tree.dat} - must be provided. It should have one row for each individual tree and the following columns: 'sample' (the tree name), 'x', 'y' (the tree position on the x and y horizontal axes), 'rad' (tree canopy radius), 'height' (tree height) and 'crown.height' (the height of the bottom of the canopy). These measurements should be in units of the horizontal distance between root samples (i.e. if root samples are one metre apart on the x and y axes, they should be in metres, but if root samples are 2 metres apart, they should be in metres / 2).
}
